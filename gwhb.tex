\documentclass[a4paper,14pt,final]{extreport}
\usepackage[microtyping,fancytop,handbook]{subook}
%\usepackage[microtyping,fancytop,handbook,cambriamath,cpcaption,firamono]{subook}
\usepackage{hyperref}
\usepackage[final]{minted}
\usepackage{graphicx}
\usepackage[normalem]{ulem}

\usemintedstyle{tango}
%\usemintedstyle{bw}
\setminted{breaklines=true,fontsize=\small,funcnamehighlighting=true}

\newcommand{\aaa}[1]{{/\bfseries #1\ldots/}}
\newcommand{\todo}[1]{{/\bfseries #1\ldots/}}

\begin{document}
\thispagestyle{empty}
\begin{center}
  \small Министерство науки и образования\\
  Российской Фежерации \\
Институт математики, экономики и информатики\\
ФБУН <<Иркутский государственный университет>>
\end{center}
\vfill
\begin{center}
  Черкашин~Е.~А.\\[2em]
  {
  \Large\bfseries Как спроектировать текст\\
выпускной квалификационной работы\\
}
\vspace{1em}
\emph{учебное пособие}
\end{center}
\vspace{8em}
\vfill
\begin{center}
  Иркутск---2017
\end{center}
\mbox{}
\newpage

\tableofcontents

\chapter*{Введение}
\label{cha:inro}

Что-то о логической структуре ВКР, а также о логических связях в структуре информации.

Структура ВКР, в целом, соответствуе структуре жизненного цикла программного обеспечения (ЖЦ ПО) \cite{lifecycle}.

\chapter{Логическая структура ВКР}
\label{cha:logstru}

Текст ВКР представляет собой отчет о проделанной работе с дополнительными комментариями.  Для того, чтобы заполнить ВКР текстом необходимо знать, прежде всего, что во время дипломной практики было сделано.  И тогда самое простое -- это написать раздел <<Заключение>>.

\section{Первый этап -- заключение}
\label{sec:coclusion}

Заключение представляет собой несколько абзацев текста, подобного следующему
\begin{quote}
В данной выпускной квалификационной работе/дипломной работе/диссертации/статье рассмотрена задача\ldots Для этого решены следующие задачи:
\begin{enumerate}
\item Исследована предметная область \ldots{};
\item Выделен набор функций, которые необходимо было реализовать;
\item Спроектирована архитектура [программной системы]; \label{item:architect}
\item При помощи \ldots{} метода разработана информационная модель \ldots{};
\item Произведена реализация [программной системы] на языке программирования \ldots{};
\item Проведено тестирование \ldots{}.
\end{enumerate}
\end{quote}

Далее делаем вывод о том, достигнута ли цель ВКР или нет и помещаем его после списка задач.

В заключении так же имеет смысл изложить в одном абзаце критические замечания по полученному результату: какие требования удалось реализовать, а какие нет; оценить качество полученного результата; показать каким образом можно удовлетворить требования и улучшить качество.

Кроме того, один абзац, последний, можно посвятить направлениям дальнейшего продвижения в разработке: что еще можно улучшить, какие функции добавить к программной системе, а какие убрать; оценить возможности программного продукта как инструмента решения более широкого класса задач.

\paragraph{Что можно улучшить в текте заключения}

Откомментировать каждую задачу, только очень кратко.  Например, в п.~\ref{item:architect} на стр \pageref{item:architect}, который посвящен архитектуре, можно указать ИЛИ название архитектуры (например, клиент--сервер), ИЛИ добавить фразу о том, как было получено решение (например, <<В результате анализа организационной структуры предприятия спроектирована архитектура \ldots{}>>).

\vspace{1em}

Теперь имеем текст заключения, который уже практически готов, к нему мы вернемся уже в самом конце для проверки его непротиворечивости основному тексту и, возможно, дополнению еще парой--тройкой фраз.

\section{Второй этап --- Введение}
\label{sec:intro}

Введение представляет собой сокращенный вариант основного текста с добавлением общей информации.  Поэтому писать введение удобно [для мозга] с середины его текста: копируем первый, третий и второй абзацы заключения (задача ВКР, список задач и вывод о достижимости цели).

Сначала изменим список задач.  Для этого выкинем из предложений все комментарии.
\begin{quote}
\ldots Для этого решены следующие задачи:
\begin{enumerate}
\item Исследована предметная область \ldots{};
\item Выделен набор функций, которые необходимо было реализовать;
\item Спроектирована архитектура [программной системы];
\item \sout{При помощи \ldots{} метода} Разработана информационная модель \ldots{};
\item Произведена реализация [программной системы] \sout{на языке программирования \ldots{}};
\item Проведено тестирование \ldots{}.
\end{enumerate}
\end{quote}
Обращаю внимание, что текст списка задач представлен в том же времени и форме, что и в заключении, так как ВКР --- это отчет о проделанной работе, а не план работ на будущее.

На следующем этапе формулируется \emph{цель}\footnote{предсказуемый результат некоторой деятельности} ВКР -- это либо проведение исследования (научная цель), разработка программы (инженерная).

Научные исследования ведутся с целью обогащения наших знаний новыми знаниями об исследуемом \emph{объекте} и его \emph{свойствах}.  Научные исследования делятся на две категории -- \emph{финдаментальные} и \emph{прикладные}.  Фундаметальные исследования направлены на решения принципиальных вопросов, например, есть ли жизнь на Марсе, или $P=NP$.  Признаком фундаментальной проблемы является ее постановка в виде вопроса, на который должен быть получен ответ -- ``Да'' или ``Нет''.  Известна метафора о прикладных исследованиях: ``Из лука стреляем в стену и вокруг места попадания рисуем мишень''.

Прикладные исследования направлены на выработку подходдов, методов и методик решения конкретных технических задач.  Примерами выступают все задачи Теории изобретательства и рационализации (ТРИЗ) \cite{altov}.

\todo{метод, методика подход}

Таким образом исследовательская цель записывается в следующем виде: ``Целью [ВКР] является исследование [такого-то] объекта и поиск в нем [таких-то] свойств/зависимостей''.

Разработка программ направлена на автоматизацию обработки информации, что на самом деле значит, что происходит процесс частичной реализации функций (задач, последовательности действий), выполняемых вручную, при помощи методов обработки информации.  Таким образом цель программистской ВКР записывается как фраза о проектировании и разработке программы или программной системы, автоматизмрующей какие-либо рутинные процессы.

Записываем цель ВКР перед списком задач.  Следующий этап -- перечисление требований к используемым методам исследования и технологиям.  Требования возникают как ограничения, накладываемые на любую деятельность.  Например, зарабатывать состояние необходимо в условиях соблюдения законодательства страны, или, если программа разрабатывается под заказ, то всегда эту программу необходимо интегрировать с существующими у заказчика программными системами и форматами данных.  Вот эти ограничения с краткими комментариями необходимо перечислить сразу после списка задач.

Пример списка требований для программной системы
\begin{quote}
  К программной системе предъявлены следущие требования:
  \begin{itemize}
  \item База данных должна быть реализована при помощи Microsoft SQL Server версии 2012;
  \item Обеспечить обмен данными с существующими программными системами при помощи технологии RESTful;
  \item Интерфейс пользователя реализовать в виде Интернет-приложения;
  \item Обеспечить доступ к приложению из любой точки мира.
  \end{itemize}
   Перечисленные требования отражают сетевую инфраструктуру предприятия--заказчика.
\end{quote}

Для исследования, например, список выглядит следующим образом:
\begin{quote}
  В процессе исследования рекомендован к использованию следующий перечень подходов и методов:
  \begin{itemize}
  \item Использовать численные методы для решения линейных дифференциальных уравнений, реализуемых на вычислительных кластерах;
  \item \ldots{}
  \end{itemize}
[комментарий, объясняющий ]
\end{quote}

Если объем ВКР предполагается большим, то принято помещать пару абзацев, излагающих общую структуру ВКР, в коце введения.

\begin{quote}
  Квалификационная работа состоит из Главый 1, где в п. 1.1 приводятся определения теории \ldots{}, в п. 1.2 представлен литературный обзор, и приводятся основные свойства [объекта исследования].  В п. 1.3 представлен предмет исследования в виде гипотезы [о наличии в системе интересующего нас свойства].  \ldots{} В главе 2 представлены собственные эксперименты, а именно в п. 2.1. \ldots Третья глава посвзена вопросам реализации разработанного аодхода на ЭВМ (в виде программной системы).  \ldots{}
 \end{quote}
Про введение в структуре ничего писать не надо, так как оно уже прочитано.  А мы ценим время читателя, которым также является и ваш рецензент.

Если к этому моменту или в процессе написания разделов появиляются новые мысли, то желательно их записывать на бумажки.  Как только вы заканчиваете мысль, абзац или раздел, надо быстро перемещаться в тот раздел, куда записанные мысли должны быть помещены, ну и, собственно, записать их туда в содержательном смысле.  Форме изложения не надо много внимания уделять, так как основная задача -- схватить мысль (grasp) и зафиксировать ее\footnote{Этот абзац как раз появился благодаря такой мысли и реализации этого принципа}.  В результате, например, во введени появится пара абзацев, касающихся какому-либо аспекту разработки, но носящие достаточно общий вид.

\subsection{Объект и предмет исследования}
К этому моменту у вас в мозгу уже долно появиться некоторое понимание того, с каким объектом исследования или автоматизации вы имеете дело.  \emph{Объект исследования} -- часть предметной области, на котороый или на часть которого направлена ваше деятельность.  Например, в задаче определения наличие жизни на Марсе объектом исследования является Марс; в задаче автоматизации бухгалтерской деятельности -- автоматизируемое предприятие.  Как правило, в качестве объекта исследования/автоматизации выступает физический или идеальный обхект, физический или идеальный процесс.  Пример объекта~--~проесса -- это автоматизация химического производства без привязки к конкретному предприятию.

Предмет исследования -- часть объекта исследования, модель которой строится\footnote{Программа -- это реализациямодели вычислительного процесса, процесса обработки информации, что тоже модель.}.  В задача с Марсом предмет исследования -- наличие различных признаков жизни, например, аминокислот в почве, наличие воды и т.д., т.е. необходимых условий существования жизни.  В задаче бухгалтерского учета предмет автоматизации -- учет материальных и денежных средств предприятия.

Объект и предмет исследования/автоматизации представляются в тексте одним абзацем каждый и помещаются последовательно где-по перед целью.

На этом с разделом введения можно на время закончить и перейти к разделу, текст которого вам написать проще всего.  Обычно -- это то, как программа пелизована, какие именно исследования были проведеный и какие результаты былиполучены, т.е. это то, что есть уже на самом деле.

\section{Собственные эксперименты\\Реализация программной системы}

Проще всего данную \textbf{главу}\footnote{} начать с описания результата: какие свойства объекта и предмета были получены, какая программная систма реализована, какие общие выводы можно сделать из результатов.

[Описание РЕЗУЛЬТАТА исследований]

Что можно сказать о программе?  Да много чего.  Общая мысль -- прорекламировать пользователям свою программу.  Пишите текст, отвечая на следующие вопросы:
\begin{enumerate}
\item Для кого предназначена программа?  Каким (конкретный класс) физическим или юридическим лицам использование вашей программ позволяет избавляться от рутинных операций, экономить материальные средства, зарабатывать больше денег, совершенствовать организационную структуру и т.п.
\item В чем состоит основная автоматизируемая функция?  Сначала дается определение.  Затем кратко перечисляются этапы автоматизируемого процесса, снабженные краткими комментариями о том, как эти этапы реализованы в программе.
\item Какие особенности у вашей программы по сравнению с программами--аналогами?  Здесь имеет смысл выделить одну-три выдающейся характеристик, которые значительно лучше, чем у остальных\footnote{У гиков этот раздел называется features}.
\item \ldots
\end{enumerate}

Полученный текст с перечислением достоинств программы (результатов исследований) помещаем в \textbf{конец главы ???}.

Общая идея представления результата -- программной системы -- состоит в том, чтобы представлять материал от общего к частному.  Т.е. по тексту главы сначала описываются модели программы, например, Функциональная модель, архитектура, ER-диаграмма (модель Чена), UML-модель классов (Диаграмма классов), \ldots{}, затем переходим к программному коду компонент, и потом уже к результатам тестирования, и т.д.  В принципе, такой порядок отражает жизненный цикл программного обеспечения \cite{ZHC}: дизайн, проектирование, реализация, тестирование, ввод в эксплуатацию, сопровождение и снятие с эксплуатации.  Все эти разделы могут быть представлены в ВКР.

Общая стратегия изложения текста ВКР в главе, посвященной реализации, -- от общего к частному.  Сначала излагаются общие вопросы, как вышеописанный перечень характристик, затем переходим к описанию моделей программы, затем к программному коду, тестированию, развертыванию и т.д.  Такой стиль изложения удобен рецензенту: рецензент является специалистом в предметной области, основных методах решения проблем, он также знаком с информаионными технологиями.  Чтобы оценить вас как специалиста, он должен понять задачу и то, как вы справились с ее решением.  Построение текста от общего к частному позволяет при чтении постепенно детализировать внимание рецензента.  Рецензент встраивает ваш ВКР в свою систему знаний.  А это удобно делать именно в этом порядке.

В начале главы надо представить читателю общую концепцию проекта вашей разработки -- в двух словах что и как вы собираетесь делать.  Например, <<Программная система представляет собой АРМ на основе реляционной базы данных, при этом, взаимодействие строится на основе клиент"=серверных технологий.>>  Из примера сразу становится видно, что собой представляет программный комплекс и каким классом программных технологий будет дальнейшее изложение ограничено.

В общих вопросах рассматривается также концепция взаимодействия пользователя с программной системой, и то, какую стратегию вы выбираете для удовлетворения требований.
\begin{quote}
  Интерфейс пользователя АРМа представляет собой динамическую WEB"=страницу.  Это позволяет решить проблему зависимости программного обеспечения от операционной системы.  Взамодействие киентской (веб"=браузер) и серверной части реализовано на основе двустороннего обмена информацией, что позволяет обеспечить обмен сообщениями между пользователями в решиме, близком к реальному времени.  Для обеспечения доступа к серверной части по проьоколу RESTful предусмотрен специальный модуль к WEB-серверу. \ldots{}
\end{quote}

\paragraph{Стиль фраз}

В примере появилась важная особенность стиля изложения текста -- \emph{доказательный}.  Важно не просто описать вашу программу -- ее возможности и то, как она устроена -- но и обосновать \textbf{каждое} вами принятое \textbf{решение}.  Чтобы проверить, удалось ли выдржать такой стиль достаточно к каждой фразе, где излагается решение задать вопросы <<Почему это так?>> и <<Зачем это нужно?>>.  Если в тексте есть фраза отвечающая на один из этих вопросов, щначит все хорошо\footnote{Вообще чаще всего задается первый вопрос.  Вопрос <<Зачем?>> надо задавать, чтобы оценивать уровень рационализма принятых решений.}.

\subsection{Место программы в организационной структуре}
\label{sec:designation}

Каждая программа где-то и кем-то используется для решения какой-то задачи.  В рамках ВКР чаще всего в качестве задачи рассматривается автоматизция обработки информации в учреждении или предприятии.  Согласно системному подходу \cite{sysap} получается, что программа является функциональным блоком нектороый организационной структуры или системы бизнес-процессов \cite{BP}.  Вот эту структуру и бизнес-процессы необходимо описать сразу после раздела общих вопросов.

\subsubsection{Организационная структура}
\label{sec:orgstruct}

Организационная структура современных учреждений представляет собой, как правило, древовидный граф иерархического подчинения, либо коммитетную матрицу.  Чтобы представить предприятие с иерархическим подчинением в ВКР надо нарисовать граф, отражающий а)~верхний уровень подчинения, б)~места отделов, где находится в эксплуатации ваша программа.  На диаграмме можно учесть также элементы организаионной структуры связанные с вашей программой коссвенно, например, в этих отделах готовят исходные данные для обработки или анализуруют отчеты.  то есть диаграмма должна отражать ту часть организационной структуры, которая связана с функционированием вашей программы.

Комитетную организационную структуру, которая встречается <<в природе>> несколько реже, удобно отображать в виде матрицы.  По горизонтали располагаются, например, виды деятельности, а по вертикали -- специалисты или отделы.  Комитетная тсруктура удобна, если предприятие занимается несколькими проектами одновременно.  Каждый проект в матрице отражается при помощи выделенных цветами клеточек.  На самом деле чисто комитетной сруктуры не бывает, всегда есть лица, ответственные за функционирование всего предприятия/учреждения.  Внутри проктов сотрудники таже выстраиваются в иерархии подчинения и ответственности.  \ldots{}В матрице выделяются проекты и клетки, в которых используется разработанная программа.

Полученная диаграмма сопровождаетя текстом пояснения, \ldots{}  В тексте в общем виде указывается, какие функции выполняет (решает задачи) программа в каждом выделенном блоке диаграммы, а также информация какого вида там преобразуется.  При чтении текста к текущему моменту становится понятным, зачем и кому нужна программа.  А вы в результате вашей творческой деятельности получили перечень функций, это перечень -- первая абстракная модель вашей программы -- \emph{функциональная модель}.

\subsubsection{Функциональная модель}
\label{sec:funmod}

Функциональная модель представляет программую систему как механизм выполняющий (исполняющий) некоторый набор функций.  Модель показывает \textbf{что} делает программа в более формальном виде, чем просто перечень свойств (фич).   Модель может учитывать связи между входными и выходными данными функций или нет.  Можно объединять функции в классы и функциональные блоки.  Функциональное моделирование выполняется при помощи различных \emph{нотаций}\footnote{Нотациями в программировании называют методы моделирования, включающие язык представления элементов моделей, правила построениая корректных моделей, семантику и интерпретацию лементов моделей и композиций.}.

\begin{description}
\item[Перечень функций] -- самцый простой метод моделирования, где функции просто перечисляются одна за одной, например в виде обощенной таблицы спецификаций.
\item[IDEF0 на основе SADT.]  IDEF0 -- это нотация иерархического представления организационной структуры сложного объекта (пердприятия, прибора и т.п.), преобразующего некоторый <<вход>> в <<выход>> при помощи <<механизма>> в условиях некоторых <<ограничений>> и под воздействием <<управления>> (см.~рис.~\ref{fig:idef0}).  Популярной методикой анализа сложного объекта и построения иерархии IDEF0-диаграмм является \emph{SADT} (Structural Analysis and Design Technique), <<методика структурного анализа и дизайна>>.
\item[Диаграмма UML UseCase] используется для моделирования программного обеспечения как граф, отражающий взаимоотношения между функциями системы и агентами, которые пользуются этими функциями.  В диаграмме можно представлять наследование свойств объектов и декомпозицию функций (рис.~\ref{fig:usecaseex}).
\item[ARIS] Европейский проект по расширению нотации IDEF0 в направлении поддержки состояний (а не только структур).  Методики проектирования, основанные на ARIS, применяются, например, в SAP/R3-системах авыматизации производства.
\item[BPMN2.0] Нотация называется Bussiness Process Modelling Notation, нотация для моедлирования бизнес-процессов.  В настоящее время едва ли не самый выразительный подход к моделированию.  Позволяет представлять как декомпозицию структуры автоматизируемого объекта, агентов, документы, потоки информации, события и состояния, но также и альтернативные пути рализации функций, задание и обработку исключений, порождение подпроцессов и т.д.  Существуют даже системы интерпретации таких моделей в виде приложений.
\end{description}

В данном пособии спользуем классический подход к функциональному моделированию -- методику SADT.  Согласно этой методике автоматизация -- это процесс преобразования организационной структуры предпроятия.   Это процесс называется \emph{реинжениринг бизнес-процессов}.  Модель IDEF0 представляет собой иерархию блоков, каэдый из которых представляет процесс (функцию преобразования входа нв выход).  Реинжениринг состоит из двух этапов: анализ структуры предприятия и выявление тех его процессов, автоматизация которых позволит улучшить качественные (упрощение организационной структуры) или количественные характеристики (производительность труда).  В результате первого этапа создается модель (иерархический набор диаграмм), называемая <<As Is>>, т.е. <<Как есть сейчас>>.   Второй этап -- преобразование результата предыдущего этапа в модель <<To Be>>.  Декомпозиция проводится при помощи программ BpWin \cite{bpwin} или \aaa{как ее там, которая на яве ;-)\cite{rrrrr}}.

При построении модели <<As is>> сначала выбирается сотрудник организации, с точки зрения которого будет производится декомпозиция бизнес-процессов.  Таким сотрудником может быть директор, бухгалер, прораб и др.  Далее рассматривется овновная функция предприятия, что она входе этой функции (деньги, люди, документы, заказы), что на выходе (деньги, люди, документы, отчеты), какиме механизмы реализуют эту функцию (сотрудники, приборы, программное обеспечение), какие ограничения накладываются на реализацию функции (законодательство Российской Федерации, стандарты отрасли).  Далее производится рекурсивная декомпозиция основной функции предприятия до уровня, где автоматизируемая вами функция представляет собой блок со входом, выходом, механизмами и ограничениями.  В результате выполнения декомпозиции вы получаете
\begin{itemize}
\item модель предприятия с различными уровнями абстракции
  представления ее деятельности;
\item понимание того, какие объекты на входе и какие на выходе, т.е. информацию об интерфейсах вашей программы;
\item перечень агентов (сотрудников), которые будут работать с вашей программной системой;
\item перечень программ, вовлеченных в реализацию функции;
\item информацию об источниках стандартизованных процедур, используемых в реализации функций программы.
\end{itemize}
Согласитесь, стоит потратить один день -- провести декомпозицию -- для того, чтобы всю эту информацию получить.

Модель <<To be>> -- это декомпозиция автоматизируемого блока на один или два дополнительных уровня с учетом реализации автоматизации.  Для построения этой модели может быть придется декомпозировать блок в модели <<As is>>, чтобы выявить автоматизируемые функции и информационные связи между ними.

Теперь остается все это оформить и описать в виде текста.  Файл с декомпозицией поместить на сервер (Dropbox или Github), чтобы специалисты могли получить доступ к вашим результатам, а в текст ВКР обучно помещвется в виде рисунка верхний уровень (функция организации) <<As is>>, модель A0, уровень, на корором выявлена автоматизируемая функция, а также декомпозиции <<As is>> и <<To be>> этой функции.  К каждому рисунку пишете по одному абзацу комментариев, где кратко описывается бизнес процесс, например, как процесс преобразования входа (в основной блок) разными функциями в разные выходы, и, в конечном счете, в выход основного блока.  Затем комментируете использование механизмов и ограничений.  Интересные конструкции, например, если выход одного блока превращается в управление/ограницение другого, или вообще в механизм, то этот процесс хорошо рассмотреть отдельно и подробно.

\subsubsection{Диаграмма прецедентов}
\label{sec:umlusecase}

На основе полученной IDEF0- фуннкциональной модели уже можно очень быстро построить UML диаграмму прецедентов.  Что она модет содержательно\footnote{Добавить конкретной новой (неповторяющеся) осмысленной информации.} дополнить -- так это указать как агенты, процессы и ресурсы наследуют свойства между сосбой.  Например, в нотариальной конторе сам нотариус может выполнять функции секретаря, т.е. готовить тексты документов.  Поэтому нотариус -- это частный случай секретаря, наследует все его свойства.  Этот факт фиксируется стрелкой с пуствм треуголником на конце (рис.~\ref{fig:notariat}).  Аналогично можно классифицировать ресурсы.

С диаграммой прецендентов долго возиться не надо.  Просто рисуем агентов, ресурсы, фукции, ставми стрелки.  Надо только внимательно отнестись к функциям -- их следует организовать в цепочки или деревья, выделяя общие части в отдельный эллипс.  Задача Use Case\;--\;диаграммы -- классифицировать повторяющиеся функции разных бизнес-процессов, выявить общие части, назначить роли агентам.

После рисунка диаграммы пишем комментирующий абзац, где в вербальной форме, например, описываются роли агентов (пользователей).

\subsection{Архитектура программной системы}
\label{sec:architecture}

Итак, вы описали функциональные модели вашей программной системы, теперь понято \textbf{что делает ваша система}, и это организационный аспект моделирования.  Теперь надо переходить к тому, как она устроена, т.е. к инженерно-организационному аспекту моделирования.

На Википедии дано следующее определение архитектуре \cite{wiki:architecture} % https://ru.wikipedia.org/wiki/%D0%90%D1%80%D1%85%D0%B8%D1%82%D0%B5%D0%BA%D1%82%D1%83%D1%80%D0%B0_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%BD%D0%BE%D0%B3%D0%BE_%D0%BE%D0%B1%D0%B5%D1%81%D0%BF%D0%B5%D1%87%D0%B5%D0%BD%D0%B8%D1%8F
\emph{Архитектура программного обеспечения} (англ. \emph{software architecture}) -- совокупность важнейших решений об организации программной системы.  Архитектура включает:
\begin{itemize}
\item выбор структурных элементов и их интерфейсов, при помощи которых сконструирована система, а также задание их поведения в рамках сотрудничества друг с другом;
\item соединение выбранных элементов структуры и поведения во более крупные системы;
\item архитектурный стиль, который задает принципиально всю организацию программной системы -- все элементы, их интерфейсы и их соединение и взаимодействие.
\end{itemize}
Документирование архитектуры программного обеспечения упрощает процесс коммуникации между разработчиками, позволяет зафиксировать принятые проектные решения и предоставить информацию о них эксплуатационному персоналу системы, повторно использовать компоненты и шаблоны проекта в других задачах.

Общепринятого определения <<архитектуры программного обеспечения>> не существует.  Так, сайт Software Engineering Institute приводит более 150 определений этого понятия.

На каком-то этапе разработки вашей программной системы вы приняли концептуальное решение, например, реализовать базу данных на сервере PostgreSQL.  Что это означает?  Это означает, что взаимодествие ядра системы с БД будет вестись по правилам <<Клиент-сервер>>, где в качестве клиента выступает ядро, а сервера -- сервер БД PostgreSQL.  Ядро с целью получения кортежей данных делает запросы к серверу, а он, в свою очередь, реализует загрузку кортежей с дисковой памяти, их фильтрацию, а ткуже другие преобразования кортежей, заканчивающиеся пересылкой данных ядру.  В качестве сервера и клиента, например, выступают веб-вервер Apache и Google Chrome, соответственно.

В тексте ВКР под описание архитектуры выделяется раздел в главе <<Реализация~\ldots>>, либо в конце главы <<Теоретические основы~\ldots{}>>.  Сначала идет абзац с общей идеей, вложенной в архитектуру, например, что она <<клиент--серверная>>.  Затем следует рисунок архитектуры.  На рисунке при помощи прямоугольников и стрелок рисуется система взаимодействия между функциональными блоками, агентами и ресурсами.

Клиент и сервер взаимодействуют друг с другом на основе некоторых заданных разработчиком правил.  Эти правила называются \emph{протоколом}.  Нарисовав архитектуру, описываем ее функциональные блоки и протоколы взаимодействия.

Предположим, что мы разрабатываем транслятор языка управления каким-нибудь АРМом, использующем базу данных, хранящююся на сервере.
\begin{quote}
  \ldots{}Архитектура системы состоит из \ldots{} функциональных блоков.  Пользователь при помощи <<Интерфейса пользователя>> (функциональный блок) вводит запросы в систему.  Запросы в виде строки (протокол) передаются на вход [функционального] блока <<Лексический анализатор>>, где входная строка преобразуется в поток лексем с соответствующими семантическими атрибутами.  Лексемы подаются на вход Синтаксического анализатора (можно писать и не с большой буквы), который создает дерево синтаксического разбора, интерпретируемое в \ldots{}
\end{quote}
Затем пишем, что там дальше происходит, как осуществляется запрос к БД: какие блоки в этом процессе участвую, какие данные передают и в какой форме.  Отслеживаем цепочку обратно.  Читателю ведь интересно, как результат запроса к БД преобразуется и выдается пользователю.

Далее добавляем пару предложений, обосновывающих эту модель, что она то, что нужно и придумать что-то лучше можно, но не особо нужно (ничего особенного новыя модель не добавит).

\subsection{Обоснование выбора технологий реализации}
\label{sec:provtech}

Следующим решением, от которого зависит то, как реализована программная система, является выбор программных технологий, при помощи которых все функциональные блоки создаются и обеспечивается их взаимодействие.  В качестве информационных технологий выступают:
\begin{itemize}
\item аппаратное обеспечение рабочих станций, серверов, сетей, маршрутизаторов и т.д.;
\item операционные системы;
\item прошивки ПЗУ устройств;
\item структуры данных -- форматы данных, теоретико-множественные представления структур данных программы (графы, категории);
\item библиотеки и готовые системы (frameworks);
\item Сервера баз данных, сторонние программы и их интерфейсы, а также отдельные функциональные блоки и динамические библиотеки;
\item программные платформы (Microsoft, Oracle, Linux/Apache/Mysql/Perl);
\item языки программирования;
\item трансляторы -- компиляторы, интерпретаторы, виртуальные машины;
\item инструментальные средства разработки (IDE).
\end{itemize}
Все перечиленное является кирпичами и инструмантами, при помощи которых создается программная система, реализуется ее архитекттура и функции в виде конкретного приложения.

В начале раздела испольуемые технологии просто можно перечислить с небольшими комментариями.
\begin{quote}
  Программная система реализована при помощи следующих информационных технологий:
  \begin{enumerate}
  \item база данных создана на основе сервера PostgreSQL версии 9.1;
  \item \ldots{}
  \item интерфейс пользователя реализован в HTML с использованием фреймворка \aaa{AngularJS};
  \item сервер приложения разработан на основе платформы Node.js и библиотеки ExpressJS для реализации интерфейса и передачи данных по протоколу RESTFul на сервер;
  \item \ldots{}
  \end{enumerate}
\end{quote}
Добавляем абзац с общим обоснованием и самокритикой этого совокупного набоора технологий.  Сопоставляем с задачами и требованиями из раздела ВКР <<Введение>>.  Только подробно по пунктам это делать не надо, иначе читатель подумает, что издеваетесь над ним.  Достаточно в общем охарактеризовать, обратив внимание на что-то действительно важное, например на основную задачу и самое <<занятное и замысловатое>> требование.

Далее в разделе под подзаголовками третьего уровня просто описываем основные функции, архитектурные особенности, протоколы, инструментарий каждой (или основных) из перечисленных технологий, обращая внимание в тексте на то как замечательно данная технология будет решать ваши задачи и удовлетворять требования.

\subsection{Информационная модель}
\label{sec:infomod}

Н.~Вирт дал такое опредеоение программе:
\begin{quote}
  Алгоритм + Структуры данных = Программа
\end{quote}
При чтении чужой программы сначала удобно изучить ее структуры данных, а потом уже алгоритмы и их реализации.  Думаю не ошибусь, если скажу, что именно структуры данных определяют общий вид программы.  Поэтому качество моделирования структур данных значительно влияют на качество всего программного проекта.

В ВКР подежат описанию структуры данных следующих классов:
\begin{enumerate}
\item Внитренние структуры данных, например, представления прафов, деревьев, списков, множеств и т.д.;
\item То же самое для внешних структур данных, данных, сохраняемых на жестких носителях;
\item Протоколы обмена между функциональными блоками по интерфейсам.
\end{enumerate}

Внутренние структуры данных, как правило, делятся на два класса -- простые, которые не разделяются на другие структуры данных, и, соответственно, сложные.  К простым относятся строки массивы, матрицы и т.п.  Может случиться так, что внутри простой структуры данных представлена сложная, например, в матрице можно закодировать граф.  В этом случае простая структура описывается так, как будто бы она сложная.

Самым простым методом описания простых структур данных является таблица спецификаций.  Таблица состоит из столбцов, выражающих расположение структуры в модулях программы, ее название, тип, размер, краткое описание назначения, диапазон допустимых значений, комментарий.  Таблица~\ref{tbl:specification} представляет собой пример таблицы спецификаций для модуля нахождения корней системы системы линейных уравнений.
\begin{table}[hbt]
  \centering
  %\begin{tabular}[pos]{}

  %\end{tabular}
  \caption[Таблица спецификаций (пример)]{Таблица спецификаций модуля решения системы линейных уравнений}
  \label{tab:specification}
\end{table}

Сложные структуры данных удобно описывать с примера конкретного типичного примера (рис.~\ref{fig:datastructex}).  На рисунке при помощи разных фигур обозначаются разные сонструктивные элементы: экземпляры классов (class), структур (struct), объединений (union).
\begin{figure}[hbt]
  \centering

  \caption[Пример структуры данных]{Структура представления формулы (пример представления структуры данных).}
  \label{fig:datastructex}
\end{figure}
Затем, в тексте даем этим конструктивным элементам вербальное (словесное) описание, либо при помощи вставок программного кода.  Графическими нотациями вида UML\;--\;Диаграмма классов удобно представлять взаимодействие на уровне классов, структур и экзмпляров классов, имеющих определенную специфику.  На этой диаграмме экземплярами, например, представляются общие ресурсы -- соединения с базами данных, мьютексы, разделяемая оперативная память и т.д.  Одним из удобных моментов использования Class Diagram является возможность задания стереотипов (например, \texttt{<<interface>>}) классам, что дает дополнительные выразительные возможности, позволяющие представлять блоками не только классы, но и структуры, объединения, перечисления, экземпляры, динамические отображения.  Можно использовать различные типы линий для отрисовки элементов диаграммы.  Заливку и поллутона лучше не использовать, т.к. при печати и отображении на проекторе стиль наверняка будет искажен.  Можно использовать стандартную штриховку, шриховку по контуру.

Скорей всего ваши структуры данных похожи на общеизвестные (деревья, графы, хэш-таблицы), для ясности можно сравнивать с одной--двумя такими структурами, выделить основные отличия.  Показать, что дает это отличие.

% Лукина, Доборходова. 5/95

\paragraph{Внешние структуры данных} представляются аналогично внутренним, только надо выделить особенности, связанные с сохранением их на носители информации.  Например, из--за того, что минимальной единицей хранения на винчестере является блок в 512 байт, размер узла индекса (сбалансированного дерева) должен бытькратен размеру блока или размеру кластера (минимальной выделяемой единице в файловой системе).  Это ограничение, как известно, приводит к тому, что приходится отходить от бинарных деревьев и переходить к $n$-арным.  Узел дерева становится уже не двойкой а динамическим массивом.  Это, в свою очередь, влияет на используемые алгоритмы преобразования (добевления и удаления узлов) дерева, а также на реализацию этих алгоритмов в виде программы.

В ВКР, связанных с разработкой информационных систем (ИС) и автоматизированных рабочих мест (АРМ), центральным звеном является хранилище данных, называемое базой данных.  Вскорей всего ваша ИС использует стандарнтые подходы к организации этого хранилища -- использует сервер реляционных баз данных.  Для этого конкретно случая методика проектирования и описания внешних структур данных специальным образом технологически уже стандартизована.  Рассмотрим подробнее эту методику.

\subsection{Структура базы данных}
\label{sec:databasestruct}

Проектирование структуры реляционной базы данных (БД) начинается с выдления сущностей (что мы храниим в БД) и атрибутов (как мы эти сущности характеризуем).  Наиболее популярен метод <<Сущность--Связь>>, в результате которого строится модель Чена в некоторой нотации (рис.~).
\begin{figure}[hbt]
  \centering

  \caption[Нотации для модели Чена]{Разнве нотации предстваления модели <<Сущность--Связь>>}
  \label{fig:changmodels}
\end{figure}
Процесс проектирования можно описать по шагам, по одному отношению (связи).  Если стркутура базы данных объемная, можно выделить только основные отношения, на основе которых строится большенство процедур обработки.  Например, в 1С~Бухгалтерии представляет основной интерес структура баз даннх проводок, документов и формат данных конфигурации системы.

Следующем шагом согласно методике является построение логической и физической модели таблиц и отношний в проектируемой БД.  Здесь пиге об основных принципах объединения отношений в таблицы и выбора типов двнных (доменов) для атрибутов.  Рисунки логической и физической моделей можно привезти как оба, либо только физическую, т.к. она -- содежательный результат примерения метода проектирования структуры БД.  В принципе можно привезти программный код DDL--интсрукций для создания одной--двух желательно связанных отношеним таблиц.

Физическая модель не показывает всего перечня индексов полей, их уникальность, поэтому пару фраз и примеров можно вставить в текст, обосновав необходимость их явного задания.

Если проектируется программная система, использующая существующую базу данных, то ее так же можно описать как всю, так и основную часть, через которую происходит взаимодействие.  Процесс аналогичен вышеописанному за исключением того факта, что БД проектировали не вы. Т.е. не надо вкладывать сислия в обоснование вами не принятых проектных решений.  Бывает так, что для реализации вашей ИС необходимо достроить существующую БД.  В этом случае опять все тоже самое, но необходимо явным образом выдлить новую часть БД (таблицы и отношения) и существовавшие ранее таблицы, с которыми происходит взаимодействие.

Методика проектирования БД включает в себя воросы проверки качества получаемого результата.  Для этого введены три нормальные формы: первая, вторая и третья, а также форма <<Бойса--Кодда>>.  Профессиональный инженер, понимая необходимость получения объективизированной оценики качества разрабатываемого продукта, стремиться его измерить.  Результаты измерения записываются в одмном-двух абзацах текста.  Можно выделить даже подраздел.

Если по каким--то причинам, например, требование производительности, масштабируемости, специфики хранимой инормации, не удается выполнить все требования, то так и пишем в тексте
\begin{quote}
  В базе данных при проектировании не удалось выполнить такое-то стандартное требование по такой-то причине.  В результате этого от хранилища данных следует ожедать такое-то аномальное поведение.  Алгоритмы такие-то будут иметь такую-то специфику и реализоваваться как-то особым образом.
\end{quote}
Типичным примером аномалии в БД является таблица с пользователями (ролями), которая, как правило, не входит во взаимодействаие с другими таблицами.  Так же как в примере с матрицей, внутри которой зашит граф, реляционную базу данных можно использовать не по ее типичному назначению.  Бвли проекты, в которых XML--БД представлялась в виде таблиц реляционной БД.  Еще оин пример -- хранение объектно--ориентированной структуры в реляционной БД.  В этом случае приходиться моделировать наследование и объединять несколько таблиц по одному общему ключевому полю.

Главное то, что не следует считать, что отклонение от пастулатов метода при проектировании -- это что-то плохое.  Вероятно ваша задача выходит за рамки класса решаемых задач этим методом.  Но, естественно, вам как будущему специалисту необходимо отдавать себе отчет о том так это или нет на самом деле.  Для сложных случаяев у вас есть руководитель ВКР, с которым следует обсудить все ключевые решения до защиты.

\subsection{Протоколы обмена данными}
\label{sec:protodescr}

Много проектов ВКР связаны с взаимодействием функциональных блоков через сеть в явном и неявном виде.  Примерами выступают ИС, построенные по трехзвенной клиент--сервеной архитектуре, сложные ИС, включающие аналитические модули из других систем.  В первом случае имеем явное сетевое взаимодействие веб-браузера и сервера приложений, во втором -- неявное, если все взаимодействующие модули находятся на одной рабочей станции, или даже в одном адресном пространстве процесса.  Так вот протоколы обмена информации для читателей вашего ВКР представляют тоже определенный интерес.  Рассмотрим пример описания протокола, используемого для доступа к системе кэширования memcached\ldots{}.

\aaa{memcached example itself shining like the Sun}


\subsection{Стандартные форматы}
\label{sec:standardformats}

В некоторых задачах решение представляется в виде программы, обрабатывающей входные данны в существующем стандартном формате.  Получается, что вы как инженер приняли решение о том, что этот стандарт следует использовать, естественно на основе глубоких рассуждений о...

\section{Алгоритмы и программные модули}
\label{sec:programmod}



\aaa{подпорки!!!!!}

\chapter{Оформление текста}
\label{cha:layout}

Структура ВКР состоит из основных и дополнительных разделов.  К основным разделам относятся:
\begin{enumerate}
\item Титульный лист, на котором представлена информация формального характера:
  \begin{itemize}
  \item вуз, в котором выполнена работа,
  \item \aaa{кафедра},
  \item название ВКР,
  \item автор и научный руководитель;
  \end{itemize}
\item Введение, где изл....;
\item Глава, посвященная изложению теоретических аспектов работы;
\item Глава, где рассмотрены аспеты реализации программного продукта;
\item Заключение, в котором кратко перечисляются полученные результаты, \aaa{самокритика} и \aaa{направления дальнейшего совершенствования}.
\item Список используемых источников (список литературы).
\end{enumerate}

\section{Текстовые объекты}
\label{sec:objs}

\subsection{Формулы}
\label{sec:formulae}

Пример правильно оформленной формулы:
\begin{equation}
  \label{eq:1}
  \vec{F} = -G\frac{Mm}{|r^3|}\vec{r},
\end{equation}
где $\vec{F}$ -- вектор силы тяжести, действующий на материальную точку массой $m$ со стороны тела (материальной точки) массой $M$, находящегося в начале координат.  Радиус"=вектор $\vec{r}$ направлен из начала координат в цетр другого тела.  Уравнение Ньютона (\ref{eq:1}) в скалярной форме выглядит в следующем виде:
\begin{equation*}
  F=G\frac{Mm}{r^2},\quad r=|\vec{r}|, F=|\vec{F}|.
\end{equation*}

\subsection{Рисунки}
\label{sec:figures}

Рисунки в тексте отображаются в разрыве текста, по центру с нумерацией и подписью.
\begin{figure}[bh]
  \centering
  \def\svgwidth{0.8\linewidth}
  \input{bodies.pdf_tex}

%%  instead of
%%   \includegraphics[width=<desired width>]{<filename>.pdf}

  \caption{Ньютоновская система двух тел}
  \label{fig:bodies}
\end{figure}


\subsection{Алгоритмы}
\label{sec:algs}

\subsection{Тексты программ}
\label{sec:sources}

\begin{minted}{java}
/* HelloWorld.java
 */

public class HelloWorld
{
	public static void main(String[] args) {
		System.out.println("Hello World!");
	}
}
\end{minted}

\begin{minted}{csharp}
// Hello3.cs
// arguments: A B C D
using System;

public class Hello3
{
   public static void Main(string[] args)
   {
      Console.WriteLine("Hello, World!");
      Console.WriteLine("You entered the following {0} command line arguments:",
         args.Length );
      for (int i=0; i < args.Length; i++)
      {
         Console.WriteLine("{0}", args[i]);
      }
   }
}
\end{minted}

\chapter{Формальные части}
\label{cha:formal}

\section{Список литературы}
\label{sec:refs}

\begin{thebibliography}{99}
\bibitem{lifecycle} Жизненный цикл программного обеспечения --- Википедия. [электронный ресурс] URL:~\url{https://ru.wikipedia.org/wiki/%D0%96%D0%B8%D0%B7%D0%BD%D0%B5%D0%BD%D0%BD%D1%8B%D0%B9_%D1%86%D0%B8%D0%BA%D0%BB_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%BD%D0%BE%D0%B3%D0%BE_%D0%BE%D0%B1%D0%B5%D1%81%D0%BF%D0%B5%D1%87%D0%B5%D0%BD%D0%B8%D1%8F} (дата обращения: 28.04.2016)
\end{thebibliography}



\end{document}

%%% Local Variables:
%%% mode: latex
%%% TeX-master: t
%%% TeX-engine: luatex
%%% End:
